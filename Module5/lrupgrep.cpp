/*
  Model with Least Recently Used (LRU) Static 
   Page Replacement Algorithm.

 The page reference stream is the same for the three algorithms.
 The number of page faults is computed for every algorithm.
 Using a Normal distribution for generating the page reference stream
 (C) J. Garrido - Nov. 1999, Rev. Feb. 2004, September 2005

 This model first generates a random sequence of page references,
 then it uses the three page replacement techniques on the same
 page sequence
 File: lrupgrep.cpp
*/
#include "proc.h"
using namespace std;

ofstream tracef;       // output data file with trace
ofstream statf;        // file for summary results

// Globals
   // Every page in the list has two components
   struct rpage{
      int page;          // page being referenced
      int p_occur;       // next occurrence in page ref stream
   };
   class gen_pgrefs;
   class lru;
//
   double simperiod;

   const int M_FRAME = 10;       // total size of frame allocation
   const int PROG_SIZE = 35;     // program size, in pages
   const int NUM_PAGES = 300;    // total pages in page ref stream

   long prstream[NUM_PAGES];  // page reference stream
//
   simulation *run;
   gen_pgrefs *pgens;  // object that generates random pafe refs
   lru *pglrurep;      // LRU
//
// vector <rpage> list_page(M_FRAME); // list of pages in memory
   typedef rpage* vector_ptr;
   vector_ptr list_page;

//
   int m_loc, m_i;
//
// Class Specifications
//
// The page reference stream is generated by an object of class gen_pgrefs
// using normal probability distribution
// An instance of this class is a passive object, instantiated from 'main'
//
   class gen_pgrefs {
   // Normal random number generator 
      long mean_pag;                  // mean page
      long std;                       // standard deviation for pages
      float cv;                       // coefficient of variance
      normal *nselect_pg;
   public:
      gen_pgrefs(string rname, long meanpg, float cvar);
      void generate();
   };
//
// Least Recently Used algorithm for page replacement
   class lru : public process {
      int mpage;             // number of pages in memory
      int j;                 // index of current ref page in pg ref stream
      int num_faults;        // number of page faults
      int ref_page;          // page being referenced
   public:
      lru (string sname);
      void Main_body();
      int get_pages();
      int get_faults();
   };
//
// Implementations
// Generate page reference stream
//
   gen_pgrefs::gen_pgrefs(string rname, long meanpg, float cvar) {
      if (meanpg > PROG_SIZE) {
         cout << "Error: mean page greater than prog size" << endl;
         meanpg = PROG_SIZE/2;
      }
      // Normal distribution with coef. of variance, cv
      cv = cvar;
      mean_pag = meanpg;
      std = long(float(mean_pag) * cv);
      // cout << "Normal - var: " << cv << " " << mean_pag << " " << std << endl;
      nselect_pg = new normal(mean_pag, std);
   }
//
   void gen_pgrefs::generate() {
      long page;
      for (int jj = 0; jj < NUM_PAGES; jj++) {
         page = (int)nselect_pg->draw();
         // discard pages out of range of the program
         while (page <= 0 || page > PROG_SIZE)
            page = (int)nselect_pg->draw();
         prstream[jj] = page;
         cout << prstream[jj] << " ";
         tracef << prstream[jj] << " ";
      }
      cout << endl;
      tracef << endl;
   }
//
// Page Replacement Algorithm
//
// ---------------------------------------------------------------
// LRU
// Replace the page in memory that has not been used for the longest
// period (of time)
   //
   lru::lru(string s) : process(s) {
      mpage = 0;            // number of pages in memory
      j = 0;
      num_faults = 0;       // number of page faults
   }

   int lru::get_faults() {
      return num_faults;
   }

   int lru::get_pages() {
      return mpage;
   }
//
   void lru::Main_body() {
      bool found = false;
      cout << endl;
      cout << "Least Recently Used (LRU) Replacement " << endl;
      cout << endl;

      // generate the page stream randomly
      // with Normal prob distribution
      pgens->generate();   

      while (j < NUM_PAGES) {
         // Get the next page referened in the page reference stream
         ref_page = prstream[j];
         cout << "Page referenced: " << ref_page << endl;
         tracef << "Page referenced: " << ref_page << endl;
         j++;
         //
         // Determine if page referenced is in memory
         //
         found = false;
         cout << "Number of pages in mem: " << mpage << endl;
         cout << "List of pages in mem: ";
         tracef << "Number of pages in mem: " << mpage << endl;
         tracef << "List of pages in mem: ";
         m_i = 0;            // index of first page
         if (mpage == 0) {  // no pages in memory yet?
            found = false;
            cout << "none" << endl;
         }
         else {
            // display pages in memory
            while (m_i < mpage) {
               cout << list_page[m_i].page << " ";
               tracef << list_page[m_i].page << " ";
               m_i++;
            }
            m_i = 0;
            cout << endl;
            tracef << endl;
            // now search for the page
            while (m_i < mpage && found == false) {
               // cout << "Searching pg: " << list_page[m_i].page << endl;
               if( list_page[m_i].page == ref_page)
                  found = true;
               else
                  m_i++;                         // compare next page
            }
         }
         // found indicates whether page is in memory
         // if page is in memory remove it, so it can be repositioned at the
         // top in the list
         if (found == true ) {
         // remove page being referenced
         // erase element m_i from list (close gap)
            if (m_i > 0) {
               for (int ii = m_i; ii > 0; ii--)
                  list_page[ii] = list_page[ii - 1];
               // mow insert new page at the top
               list_page[0].page = ref_page;
            }
         }
         else {
            // if page not in memory, a page fault occurs
            // if there are no free frames, the last page is removed
            num_faults++;             // page fault
            // cout << "Page fault, accum pg faults: " << num_faults << endl;
            if (mpage < M_FRAME)     // frames available?
               mpage++;
            // shift down all pages
            for (int ii = mpage-1; ii > 0; ii--)
               list_page[ii].page = list_page[ii-1].page;
            // now insert page at the top of list
            list_page[0].page = ref_page;
         }
      }    // end while for all pages in page reference stream


      terminate();
   } // end LRU Main_body
   //

//
//
// -------------------------------------------------------------
//
   class pgreplace : public process {
   public: 
      pgreplace(string s);
      void Main_body();
   };
//
   pgreplace::pgreplace (string s) : process(s) {
      // cout << s << " created" << endl;
   }
//
   void pgreplace::Main_body() {
      int num_pages;
      int num_faults;
      //
      pglrurep = new lru("LRU");
      pglrurep->pstart();
      
      //
      run->start_sim(simperiod);

      num_faults = pglrurep->get_faults();
      num_pages = pglrurep->get_pages();

      cout << endl;
      cout << "LRU - Total page faults: " << num_faults << endl;
      cout << "Total number of page references: " << num_pages << endl;
      cout << "Proportion of pg faults to pg refs.: "
           << float(num_faults)/float(num_pages) << endl;
      cout << endl;
      statf << endl;
      statf << "LRU - Total page faults: " << num_faults << endl;
      statf << "Total number of page references: " << num_pages << endl;
      statf << "Proportion of pg faults to pg refs.: "
           << float(num_faults)/float(num_pages) << endl;
      statf << endl;

   }
//
   int main () {
      pgreplace *prep_model;
      simperiod = 600.5;
      list_page = new rpage[M_FRAME];  // create array
      long mean_pg = 20;               // mean page
      float cvar = 0.55f;              // coefficient of variance   
      //
      run = new simulation ("LRU Page Replacement Algorithm");

      run->set_statfile("lrupgrep_stat.txt", statf);
      run->set_tracefile("lrupgrep_trace.txt", tracef);
      //
      pgens = new gen_pgrefs("Generate page stream", mean_pg, cvar);
      //
      // control thread
      prep_model = new pgreplace("Control thread Pg Rep");
      prep_model->pstart();
      //
      run->end_sim();
      return 0;
   }

