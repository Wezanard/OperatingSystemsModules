/*
 This program implements the Optimal 
 page replacement algorithm

 The page reference stream is the same for the three algorithms.
 The number of page faults is computed for every algorithm.
 Using a Normal distribution for generating the page reference stream


 This model first generates a random sequence of page references,
 then it uses the three page replacement techniques on the same
 page sequence.
 
  (C) J. Garrido - Nov. 1999, Rev. Feb. 2004, September 2005.
 File: optpgrep.cpp
*/ 
#include "proc.h"
using namespace std;

ofstream tracef;       // output data file with trace
ofstream statf;        // file for summary results

// Globals
   // Every page in the list has two components
   struct rpage{
      int page;          // page being referenced
      int p_occur;       // next occurrence in page ref stream
   };
   class gen_pgrefs;
   class optimal;
//
   double simperiod;

   const int M_FRAME = 10;       // total size of frame allocation
   const int PROG_SIZE = 35;     // program size, in pages
   const int NUM_PAGES = 300;    // total pages in page ref stream

   long prstream[NUM_PAGES - 1];  // page reference stream
//
   simulation *run;
   gen_pgrefs *pgens;  // object that generates random pafe refs
   optimal *pgoptrep;  // Optimal page replacement
//
// vector <rpage> list_page(M_FRAME); // list of pages in memory
   typedef rpage* vector_ptr;
   vector_ptr list_page;

//
   int m_loc, m_i;
//
// Class Specifications
//
// The page reference stream is generated by an object of class gen_pgrefs
// using normal probability distribution
// An instance of this class is a passive object, instantiated from 'main'
//
   class gen_pgrefs {
   // Normal random number generator 
      long mean_pag;                  // mean page
      long std;                       // standard deviation for pages
      float cv;                       // coefficient of variance
      normal *nselect_pg;
   public:
      gen_pgrefs(string rname, long meanpg, float cvar);
      void generate();
   };
//
   // Optimal algorithm for page replacement
   class optimal : public process {
      int mpage;             // number of pages in memory
      int j;                 // index of current ref page in pg ref stream
      int num_faults;        // number of page faults
      long ref_page;         // page being referenced
      rpage cpage;           // current page and occurrence
   public:
      optimal (string sname);
      void Main_body();
      int get_faults();
      int get_pages();
   };
   //
// Implementations
// Generate page reference stream
//
   gen_pgrefs::gen_pgrefs(string rname, long meanpg, float cvar) {
      if (meanpg > PROG_SIZE) {
         cout << "Error: mean page greater than prog size" << endl;
         meanpg = PROG_SIZE/2;
      }
      // Normal distribution with coef. of variance, cv
      cv = cvar;
      mean_pag = meanpg;
      std = long(float(mean_pag) * cv);
      // cout << "Normal - var: " << cv << " " << mean_pag << " " << std << endl;
      nselect_pg = new normal(mean_pag, std);
   }
//
   void gen_pgrefs::generate() {
      long page;
      for (int jj = 0; jj < NUM_PAGES; jj++) {
         page = (int)nselect_pg->draw();
         // discard pages out of range of the program
         while (page <= 0 || page > PROG_SIZE)
            page = nselect_pg->draw();
         prstream[jj] = page;
         cout << prstream[jj] << " ";
         tracef << prstream[jj] << " ";
      }
      // cout << endl;
   }
//
// Page Replacement Algorithms
// Optimal
// Replace the page that will not be used for the longest period
//
   optimal::optimal(string s) : process(s) {
      mpage = 0;
      j = 0;
      num_faults = 0;
   }
 int optimal::get_faults() {
     return num_faults;
 }

 int optimal::get_pages() {
     return mpage;
 }
//
   void optimal::Main_body() {
     //
     cout << endl;
     cout << endl;
     cout << "Optimal Page Replacement " << endl;
     cout << endl;

      // generate the page stream randomly
      // with Normal prob distribution
      pgens->generate();   

     while (j < NUM_PAGES) {
         // REF_PAGE
         // Get the next page referened from the page reference stream
         ref_page = prstream[j];
         j++;
         //
         // NEXT_OCCURRENCE
         // Determine the next occurrence of the page being referenced
         int k = j;
         bool found = false;
         while ( k < NUM_PAGES && found == false) {
            if (ref_page == prstream[k])
               found = true;
            else
               k++;                        // keep searching
         }
         //
         if (found == false)
            k = NUM_PAGES + 10;
         // cout << endl;
         cout << "Page referenced: " << ref_page << endl;
         tracef << "Page referenced: " << ref_page << endl;
         // store this in cpage structure
         cpage.page = ref_page;
         cpage.p_occur = k;                 // next occurrence of this page
         //
         //  SEARCH_IN_MEMORY
         // Determine if page referenced is in memory
         //
         found = false;
         m_i = 0;            // index of fist page in memory
         cout << "Number of pages in mem: " << mpage << endl;
         cout << "List of pages in mem: ";
         tracef << "Number of pages in mem: " << mpage << endl;
         tracef << "List of pages in mem: ";
         if (mpage == 0) {
            found = false;
            cout << "none" << endl;
         }
         else {
            while (m_i < mpage) {
               cout << list_page[m_i].page << " ";
               tracef << list_page[m_i].page << " ";
               m_i++;
            }
            m_i = 0;
            cout << endl;
            while (m_i < mpage && found == false) {
               // cout << "Comparing with pg: " << list_page[m_i].page << endl;
               if( list_page[m_i].page == ref_page)
                  found = true;
               else
                  m_i++;                         // compare next cpage
            }
         }
         // cout << endl;
         // found indicates whether page is in memory
         // if page is in memory remove it, so it can be repositioned at the
         // appropriate place in the list
         if (found == true) {
         // remove page being referenced
         // erase element m_i from list (close gap)
            for (int ii = m_i; ii < mpage; ii++)
               list_page[ii] = list_page[ii + 1];
            mpage--;                  // decrease number of pages in memory
         }
         // PAGE_FAULT
         else {
            // if page is not in memory, a page fault occurs
            // if there are no free frames, the last page is removed
            num_faults++;             // page fault
            cout << "Page fault, accum pg faults: " << num_faults << endl;
            tracef << "Page fault, accum pg faults: " << num_faults << endl;
            if (mpage == M_FRAME) {   // all frames full?
            // remove page at bottom of list
               list_page[M_FRAME-1].page = NUM_PAGES+1;
               mpage--;
            }
         }
         // LOAD_PAGE
         // Insert current page at an apropriate place in the list
         // Search list for first page with a larger value for next occurrence
         // in the page reference stream, compared to the current page
         //
         int k_occur = cpage.p_occur; // next occurrence of currently referenced page
         found = false; 
         m_i = 0;
         while ( m_i < mpage && found == false ) {
            // cout << "Comparing page: " << list_page[m_i].page << endl;
            if (list_page[m_i].p_occur > k_occur) {
               // cout << "Indx page with larger value of future occurrence "
               //     << m_i << endl;
               m_loc = m_i;                // index location of element found
               found = true;
            }
            else
               m_i++;
         }
         if(mpage == 0)           // no pages in list yet
            m_i = 0;
         else
            m_i = mpage;
      //
      // REARRANGE_PAGES
      // if no element found with larger occurrence in the list,
      //   add new element to tail of list
         if (found == false) {
            list_page[m_i].page = cpage.page;
            list_page[m_i].p_occur = cpage.p_occur;
         }
         else {
         // insert elemnt at m_loc location
         // open gap
            for(int ii = mpage; ii >= m_loc; ii--)
               list_page[ii] = list_page[ii - 1];
         // now insert element
            list_page[m_loc].page = cpage.page;
            list_page[m_loc].p_occur = cpage.p_occur;
         }
         mpage++;
      //
      //  RESULTS
      }    // end while for all pages in page reference stream

      terminate();
   } // end Optimal Main_body
//
//
//
// -------------------------------------------------------------
//
   class pgreplace : public process {
   public: 
      pgreplace(string s);
      void Main_body();
   };
//
   pgreplace::pgreplace (string s) : process(s) {
      // cout << s << " created" << endl;
   }
//
   void pgreplace::Main_body() {
      int num_faults;
      int num_pages;

      //
      pgoptrep = new optimal("Optimal");
      pgoptrep->pstart();      
      //
      run->start_sim(simperiod);

      num_faults = pgoptrep->get_faults();
      num_pages = pgoptrep->get_pages();

      cout << endl;
      cout << "Optimal - Total page faults: " << num_faults << endl;
      cout << "Total number of page references: " << num_pages << endl;
      cout << "Proportion of pg faults to pg refs.: "
         << float(num_faults)/float(num_pages) << endl;
      cout << endl;
      statf << endl;
      statf << "Optimal - Total page faults: " << num_faults << endl;
      statf << "Total number of page references: " << num_pages << endl;
      statf << "Proportion of pg faults to pg refs.: "
         << float(num_faults)/float(num_pages) << endl;
      statf << endl;

   }
//
   int main () {
      pgreplace *prep_model;
      simperiod = 100.5;
      list_page = new rpage[M_FRAME];  // create array
      long mean_pg = 20;        // mean page
      float cvar = 0.55f;        // coefficient of variance   
      //
      run = new simulation ("Optimal Page Replacement Algorithm");

      run->set_statfile("optpgrep_stat.txt", statf);
      run->set_tracefile("optpgrep_trace.txt", tracef);

      statf <<  "Simulation of Optimal Page Replacement" << endl;
      statf << "-----------------------------------------------------------" << endl;
      cout <<  "Simulation of Optimal Page Replacement" << endl;
      cout << "-----------------------------------------------------------" << endl;
      //
      pgens = new gen_pgrefs("Generate page stream", mean_pg, cvar);
      //
      // control thread
      prep_model = new pgreplace("Control thread Pg Rep");
      prep_model->pstart();
      //
      run->end_sim();
      return 0;
   }

