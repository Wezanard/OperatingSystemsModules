/*
 This program implements First In First Out (FIFO) 
  page replacement algorithm.

 The page reference stream is the same for the three algorithms.
 The number of page faults is computed for every algorithm.
 Using a Normal distribution for generating the page reference stream

 This model first generates a random sequence of page references,
 then it uses the three page replacement techniques on the same
 page sequence
 
 (C) J. Garrido - Nov. 1999, Rev. Feb. 2004
 File: fifopgrep.cpp
*/

#include "proc.h"

using namespace std;

ofstream tracef;       // output data file with trace
ofstream statf;        // file for summary results

// Globals
   // Every page in the list has two components
   struct rpage{
      int page;          // page being referenced
      int p_occur;       // next occurrence in page ref stream
   };
     
   double simperiod;

   const int M_FRAME = 10;       // total size of frame allocation
   const int PROG_SIZE = 35;     // program size, in pages
   const int NUM_PAGES = 300;    // total pages in page ref stream

   long prstream[NUM_PAGES];  // page reference stream

   // class for generation of random sequence of page references   
   class gen_pgrefs;
   // class with fifo algorithm
   class fifo;     

   simulation *run;
   gen_pgrefs *pgens;  // object that generates random pafe refs
   fifo *pgfiforep;    // FIFO
//
// vector <rpage> list_page(M_FRAME); // list of pages in memory
   typedef rpage* vector_ptr;
   vector_ptr list_page;

//
   int m_loc, m_i;
//
// Class Specifications
//
// The page reference stream is generated by an object of class gen_pgrefs
// using normal probability distribution
// An instance of this class is a passive object, instantiated from 'main'
//
   class gen_pgrefs {
   // Normal random number generator 
      long mean_pag;                  // mean page
      long std;                       // standard deviation for pages
      float cv;                       // coefficient of variance
      normal *nselect_pg;
   public:
      gen_pgrefs(string rname, long meanpg, float cvar);
      void generate();
   };
//
//
// FIFO Algorithm for page replacement
   class fifo : public process {
      int mpage;           // number of pages in memory
      int j;               // index of current referenced page in page ref stream
      int num_faults;      // number of page faults
      int ref_page;        // page being referenced
   public:
      fifo (string sname);
      void Main_body();
      int get_faults(); // get total page faults
      int get_pages();    // get total pages referenced
   };


   class pgreplace : public process {
   public: 
      pgreplace(string s);
      void Main_body();
   };

   //
// Implementations
// Generate page reference stream
//
   gen_pgrefs::gen_pgrefs(string rname, long meanpg, float cvar) {
      if (meanpg > PROG_SIZE) {
         cout << "Error: mean page greater than prog size" << endl;
         meanpg = PROG_SIZE/2;
      }
      // Normal distribution with coef. of variance, cv
      cv = cvar;
      mean_pag = meanpg;
      std = long(float(mean_pag) * cv);
      // cout << rname << " Normal - var: " << cv << " " << mean_pag << " " << std << endl;
      nselect_pg = new normal(mean_pag, std);
   }
//
   void gen_pgrefs::generate() {
      long page;
      cout << "Generating page references" << endl;
      tracef << "Generating page references" << endl;
      for (int jj = 0; jj < NUM_PAGES; jj++) {
         page = (int)nselect_pg->draw();
         // discard pages out of range of the program
         while (page <= 0 || page > PROG_SIZE)
            page = (int)nselect_pg->draw();
         prstream[jj] = page;
         cout << prstream[jj] << " ";
         tracef << prstream[jj] << " ";
      }
      cout << "\n End of generation pg refs" << endl;
      tracef << "\n End of generation pg refs" << endl;
   }
//
// Page Replacement Algorithms

//
// ---------------------------------------------------------------
//
// FIFO Page Replacement Algorithm
// Replace the page that has been in memory the longest
// Insert new page at the top, remove page at the bottom

   fifo::fifo(string s) : process(s) {
      mpage = 0;
      j = 0;
      num_faults = 0;
      // cout << s << " created" << endl;
   }
//
   void fifo::Main_body() {
      bool found = false;
      double pgreft;
      double pgfaultt;
      // cout << endl;
      cout << "FIFO page Replacement " << endl;
      // cout << endl;
      pgreft = 2.5;
      pgfaultt = 13.5;

      // generate the page stream randomly
      // with Normal prob distribution
      pgens->generate();   

      while ((get_clock() < simperiod) && (j < NUM_PAGES)) {
         // Get the next page referened in the page reference stream
         ref_page = prstream[j];
         cout << "Page referenced: " << ref_page << endl;
         tracef << "Page referenced: " << ref_page << endl;
         j++;
         delay(pgreft);
         // Determine if page referenced is in memory
         found = false;
         cout << "Number of pages in mem: " << mpage << endl;
         cout << "List Pages in mem: ";
         tracef << "Number of pages in mem: " << mpage << endl;
         tracef << "List Pages in mem: ";
         m_i = 0;            // index of first page
         if (mpage == 0)  {  // no pages in memory?
            found = false;
            cout << "none" << endl;
         }   
         else {
            // display pages in memory
            while (m_i < mpage) {
               cout << list_page[m_i].page << " ";
               tracef << list_page[m_i].page << " ";
               m_i++;
            }
            m_i = 0;
            cout << endl;
            tracef << endl;
            while (m_i < mpage && found == false) {
               // cout << "Searching pg: " << list_page[m_i].page << endl;
               if( list_page[m_i].page == ref_page)
                  found = true;
               else
                  m_i++;                         // compare next page
            }
         }
         // cout << endl;
         // found indicates whether page is in memory
         // if page is in memory leave it in the same position in the list

         // page fault
         if (found == false ) {
            // if page not in memory, a page fault occurs
            // if there are no free frames, the last page is removed
            num_faults++;             // page fault
            cout << "Page fault, accum pg faults: " << num_faults << endl;
            tracef << "Page fault, accum pg faults: " << num_faults << endl;
            if (mpage < M_FRAME)     // frames available?
               mpage++;

            delay(pgfaultt);

            // shift down all pages
            for (int ii = mpage-1; ii > 0; ii--)
               list_page[ii].page = list_page[ii-1].page;
            // now insert page at the top of list
            list_page[0].page = ref_page;
         }
      }    // end while for all pages in page reference stream
	  
      cout << endl;
      tracef << endl;

      // terminate();
   } // end fifo Main_body

 int fifo::get_faults() {
     return num_faults;
 }

 int fifo::get_pages() {
     return j;
 }


//
//
// -------------------------------------------------------------

//
   pgreplace::pgreplace (string s) : process(s) {
      // cout << s << " created" << endl;
   }
//
   void pgreplace::Main_body() {
      int num_faults;
      int num_pages;
 
      //
      pgfiforep = new fifo("FIFO");
	  
      // cout << "starting fifo" << endl;
	  
      pgfiforep->pstart();
	  
      // cout << " after starting fifo" << endl;
      //
      run->start_sim(simperiod);  // start simulation
       
      num_faults = pgfiforep->get_faults();
      num_pages = pgfiforep->get_pages();
      cout << endl;
      cout << "FIFO - Total page faults: " << num_faults << endl;
      cout << "Total number of page references: " << num_pages << endl;
      cout << "Proportion of pg faults to pg refs.: "
           << float(num_faults)/float(num_pages) << endl;
      cout << endl;
      statf << endl;
      statf << "FIFO - Total page faults: " << num_faults << endl;
      statf << "Total number of page references: " << num_pages << endl;
      statf << "Proportion of pg faults to pg refs.: "
           << float(num_faults)/float(num_pages) << endl;
      statf << endl;

   }
//
   int main () {
      pgreplace *prep_model;

      simperiod = 3000.0;
      list_page = new rpage[M_FRAME];  // create array
      long mean_pg = 20;        // mean page
      float cvar = 0.55f;        // coefficient of variance   
      //
      run = new simulation ("FIFO Page Replacement");
  
      run->set_statfile("fifopgrep_stat.txt", statf);
      run->set_tracefile("fifopgrep_trace.txt", tracef);
  
      statf <<  "Simulation of FIFO Page Replacement" << endl;
      statf << "-----------------------------------------------------------" << endl;
      cout <<  "Simulation of FIFO Page Replacement" << endl;
      cout << "-----------------------------------------------------------" << endl;
      //
      pgens = new gen_pgrefs("Generate page stream", mean_pg, cvar);
      //
      // control thread
      prep_model = new pgreplace("Control thread Pg Rep");
      prep_model->pstart();
      //
      run->end_sim();   // end simulation
      return 0;
   }

